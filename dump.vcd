// Copyright (c) 2023 Sungkyunkwan University
//
// Authors:
// - Jungrae Kim <dale40@skku.edu>
//**********************************************
//수정해야할 것
// data FIFO 입력과 출력의 data가 매칭이 안됨. (rresp [1:0] <-> wstrb [3:0])
//**********************************************
module DMAC_TOP
(
    input   wire                clk,
    input   wire                rst_n,  // _n means active low

    // AMBA APB interface
    input   wire                psel_i,
    input   wire                penable_i,
    input   wire    [11:0]      paddr_i,
    input   wire                pwrite_i,
    input   wire    [31:0]      pwdata_i,
    output  reg                 pready_o,
    output  reg     [31:0]      prdata_o,
    output  reg                 pslverr_o,

    // AMBA AXI interface (AW channel)
    output  wire    [3:0]       awid_o,
    output  wire    [31:0]      awaddr_o,
    output  wire    [3:0]       awlen_o,
    output  wire    [2:0]       awsize_o,
    output  wire    [1:0]       awburst_o,
    output  wire                awvalid_o,
    input   wire                awready_i,

    // AMBA AXI interface (W channel)
    output  wire    [3:0]       wid_o,
    output  wire    [31:0]      wdata_o,
    output  wire    [3:0]       wstrb_o,
    output  wire                wlast_o,
    output  wire                wvalid_o,
    input   wire                wready_i,

    // AMBA AXI interface (B channel)
    input   wire    [3:0]       bid_i,
    input   wire    [1:0]       bresp_i,
    input   wire                bvalid_i,
    output  wire                bready_o,

    // AMBA AXI interface (AR channel)
    output  wire    [3:0]       arid_o,
    output  wire    [31:0]      araddr_o,
    output  wire    [3:0]       arlen_o,
    output  wire    [2:0]       arsize_o,
    output  wire    [1:0]       arburst_o,
    output  wire                arvalid_o,
    input   wire                arready_i,

    // AMBA AXI interface (R channel)
    input   wire    [3:0]       rid_i,
    input   wire    [31:0]      rdata_i,
    input   wire    [1:0]       rresp_i,
    input   wire                rlast_i,
    input   wire                rvalid_i,
    output  wire                rready_o
);
    localparam                  N_CH    = 4;

    wire    [31:0]              src_addr_vec[N_CH];
    wire    [31:0]              dst_addr_vec[N_CH];
    wire    [15:0]              byte_len_vec[N_CH];
    wire                        start_vec[N_CH];
    wire                        done_vec[N_CH];

    // FIXME: implement DMAC pipelining  이 위로는 fixed
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

//벡터 = INI에서 나오는 애들 4ch 묶인 것
    wire    [3:0]               awid_vec[N_CH];
    wire    [31:0]              awaddr_vec[N_CH];
    wire    [3:0]               awlen_vec[N_CH];
    wire    [2:0]               awsize_vec[N_CH];
    wire    [1:0]               awburst_vec[N_CH];
    // wire                        awvalid_vec[N_CH];
    // wire                        aw_fifo_valid_vec[N_CH]; 뒤에 써줌
    // wire                        awready_vec[N_CH];
    // wire                        aw_fifo_ready_vec[N_CH];

    wire    [3:0]               wid_vec[N_CH];
    wire    [31:0]              wdata_vec[N_CH];
    wire    [3:0]               wstrb_vec[N_CH];
    wire                        wlast_vec[N_CH];
    wire                        wvalid_vec[N_CH];
    wire                        wready_vec[N_CH];
    wire                        bready_vec[N_CH];
    wire    [3:0]               arid_vec[N_CH];
    wire    [31:0]              araddr_vec[N_CH];
    wire    [3:0]               arlen_vec[N_CH];
    wire    [2:0]               arsize_vec[N_CH];
    wire    [1:0]               arburst_vec[N_CH];
    wire                        arvalid_vec[N_CH];
    wire                        arready_vec[N_CH];
    wire                        rready_vec[N_CH];

    /////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////
    
    wire    [3:0]               aw_fifo_id_vec[N_CH];
    wire    [31:0]              aw_fifo_addr_vec[N_CH];
    wire    [3:0]               aw_fifo_len_vec[N_CH];
    wire    [2:0]               aw_fifo_size_vec[N_CH];
    wire    [1:0]               aw_fifo_burst_vec[N_CH];
    wire                        aw_fifo_valid_vec[N_CH];
    wire                        aw_fifo_ready_vec[N_CH];

    wire                        aw_arb2fifo_valid;
    // wire                        aw_arb2fifo_ready;
    wire    [3:0]               aw_arb2fifo_id; 
    wire    [31:0]              aw_arb2fifo_addr;  
    wire    [3:0]               aw_arb2fifo_len; 
    wire    [2:0]               aw_arb2fifo_size; 
    wire    [1:0]               aw_arb2fifo_burst;

    wire                        aw_fifo_full;
    wire                        aw_fifo_empty;

    wire                        data_fifo_full;
    wire                        data_fifo_empty;
    
    /////////////////////////////////////////////////////////////
    /////////////////////////////////////////////////////////////

    DMAC_CFG u_cfg(
        .clk                    (clk),
        .rst_n                  (rst_n),

        // AMBA APB interface
        .psel_i                 (psel_i),
        .penable_i              (penable_i),
        .paddr_i                (paddr_i),
        .pwrite_i               (pwrite_i),
        .pwdata_i               (pwdata_i),
        .pready_o               (pready_o),
        .prdata_o               (prdata_o),

        .ch0_src_addr_o        (src_addr_vec[0]),
        .ch0_dst_addr_o           (dst_addr_vec[0]),
        .ch0_byte_len_o        (byte_len_vec[0]),
        .ch0_start_o          (start_vec[0]),
        .ch0_done_i            (done_vec[0]),

        .ch1_src_addr_o        (src_addr_vec[1]),
        .ch1_dst_addr_o           (dst_addr_vec[1]),
        .ch1_byte_len_o        (byte_len_vec[1]),
        .ch1_start_o          (start_vec[1]),
        .ch1_done_i            (done_vec[1]),

        .ch2_src_addr_o        (src_addr_vec[2]),
        .ch2_dst_addr_o           (dst_addr_vec[2]),
        .ch2_byte_len_o        (byte_len_vec[2]),
        .ch2_start_o          (start_vec[2]),
        .ch2_done_i            (done_vec[2]),

        .ch3_src_addr_o        (src_addr_vec[3]),
        .ch3_dst_addr_o           (dst_addr_vec[3]),
        .ch3_byte_len_o        (byte_len_vec[3]),
        .ch3_start_o          (start_vec[3]),
        .ch3_done_i            (done_vec[3])
    );

   assign   pslverr_o         = 1'b0;

    DMAC_ARBITER #(
        .N_MASTER               (N_CH),
        .DATA_SIZE              ($bits(arid_o)+$bits(araddr_o)+$bits(arlen_o)+$bits(arsize_o)+$bits(arburst_o))
    )
    u_ar_arbiter
    (
        .clk                    (clk),
        .rst_n                  (rst_n),

        .src_valid_i            (arvalid_vec),
        .src_ready_o            (arready_vec),
        .src_data_i             ({
                                  {arid_vec[0], araddr_vec[0], arlen_vec[0], arsize_vec[0], arburst_vec[0]},
                                  {arid_vec[1], araddr_vec[1], arlen_vec[1], arsize_vec[1], arburst_vec[1]},
                                  {arid_vec[2], araddr_vec[2], arlen_vec[2], arsize_vec[2], arburst_vec[2]},
                                  {arid_vec[3], araddr_vec[3], arlen_vec[3], arsize_vec[3], arburst_vec[3]}}),

        .dst_valid_o            (arvalid_o),
        .dst_ready_i            (arready_i),
        .dst_data_o             ({arid_o, araddr_o, arlen_o, arsize_o, arburst_o})
    );



    DMAC_ARBITER #(
        .N_MASTER               (N_CH),
        .DATA_SIZE              ($bits(awid_o)+$bits(awaddr_o)+$bits(awlen_o)+$bits(awsize_o)+$bits(awburst_o))
    )
    u_aw_arbiter
    (
        .clk                    (clk),
        .rst_n                  (rst_n),

                                //INI -> Arbiter
        .src_valid_i            (aw_fifo_valid_vec),
        .src_ready_o            (aw_fifo_ready_vec),
        .src_data_i             ({
                                  {aw_fifo_id_vec[0], aw_fifo_addr_vec[0], aw_fifo_len_vec[0], aw_fifo_size_vec[0], aw_fifo_burst_vec[0]},
                                  {aw_fifo_id_vec[1], aw_fifo_addr_vec[1], aw_fifo_len_vec[1], aw_fifo_size_vec[1], aw_fifo_burst_vec[1]},
                                  {aw_fifo_id_vec[2], aw_fifo_addr_vec[2], aw_fifo_len_vec[2], aw_fifo_size_vec[2], aw_fifo_burst_vec[2]},
                                  {aw_fifo_id_vec[3], aw_fifo_addr_vec[3], aw_fifo_len_vec[3], aw_fifo_size_vec[3], aw_fifo_burst_vec[3]}}),

        .dst_valid_o            (aw_arb2fifo_valid),  //아비터->FIFO
        .dst_ready_i            (!aw_fifo_full),  //아비터->FIFO
        .dst_data_o             ({aw_arb2fifo_id, aw_arb2fifo_addr, aw_arb2fifo_len, aw_arb2fifo_size, aw_arb2fifo_burst})
    );



    assign  bready_o                = (bid_i=='d0) ? bready_vec[0] :
                                      (bid_i=='d1) ? bready_vec[1] :
                                      (bid_i=='d2) ? bready_vec[2] :
                                                     bready_vec[3];


//rready는 data FIFO가 줌. 이 코드는 안씀!
    // assign  rready_o                = (rid_i=='d0) ? rready_vec[0] :
    //                                   (rid_i=='d1) ? rready_vec[1] :
    //                                   (rid_i=='d2) ? rready_vec[2] :
    //                                                  rready_vec[3];



    DMAC_FIFO  #(
        .DEPTH_LG2               (2),
        .DATA_WIDTH              ($bits(awid_o)+$bits(awaddr_o)+$bits(awlen_o)+$bits(awsize_o)+$bits(awburst_o))
    )
    aw_fifo
    (
        .clk                        (clk),
        .rst_n                      (rst_n),

        .full_o                     (aw_fifo_full),
        .wren_i                     (!aw_fifo_full & aw_arb2fifo_valid),
        .wdata_i                    ({aw_arb2fifo_id, aw_arb2fifo_addr, aw_arb2fifo_len, aw_arb2fifo_size, aw_arb2fifo_burst}),

        .empty_o                    (aw_fifo_empty),
        .rden_i                     (!aw_fifo_empty & awready_i),
        .rdata_o                    ({awid_o, awaddr_o, awlen_o, awsize_o, awburst_o})
    );
        
        assign  awvalid_o        = !aw_fifo_empty;

//data fifo에서  실제wdata, w strobe,w last가 뭉탱이로 나갈 수 있게 수정해야함(ini에서 안나가고) 
///  rlast를 wlast로 쓰자...  rresp 정체?,  
// data fifo에 들어올 때  {rid_o, rdata_o, "rresp_o", rlast_o}
//                나갈때  {wid_o, wdata_o, "wstrb_o", wlast_o} 매칭이 안됨
// strobe는 ini가 줌!, data fifo는 resp 안받음!
    DMAC_FIFO   #(
        .DEPTH_LG2               (2),
        // .DATA_WIDTH              ($bits(rid_i)+$bits(rdata_i)+$bits(rresp_i)+$bits(rlast_i))
        .DATA_WIDTH              ($bits(rid_i)+$bits(rdata_i)+$bits(rlast_i))
    )
    data_fifo
    (
        .clk                        (clk),
        .rst_n                      (rst_n),

        .full_o                     (data_fifo_full),
        .wren_i                     (!data_fifo_full & rvalid_i),
        .wdata_i                    ({rid_i, rdata_i, rlast_i}),

        .empty_o                    (data_fifo_empty),
        .rden_i                     (!data_fifo_empty & wready_i),
        .rdata_o                    ({wid_o, wdata_o, wlast_o})
    );

        assign  rready_o        = !data_fifo_full;
        assign  wvalid_o        = !data_fifo_empty;

    genvar ch;
    generate
        for (ch=0; ch<N_CH; ch++) begin: channel
            DMAC_INITIATOR u_initiator(
                .clk                    (clk),
                .rst_n                  (rst_n),
        
                // configuration registers
                .src_addr_i             (src_addr_vec[ch]),
                .dst_addr_i             (dst_addr_vec[ch]),
                .byte_len_i             (byte_len_vec[ch]),
                .start_i                (start_vec[ch]),
                .done_o                 (done_vec[ch]),

/////////////////////////////////////////////////////
                 //INI -> ARBITER -> AW FIFO
                .aw_fifo_addr_o          (aw_fifo_addr_vec[ch]),
                .aw_fifo_valid_o         (aw_fifo_valid_vec[ch]),
                .aw_fifo_ready_i         (aw_fifo_ready_vec[ch]),

                .aw_fifo_len_o           (aw_fifo_len_vec[ch]),
                .aw_fifo_size_o          (aw_fifo_size_vec[ch]),
                .aw_fifo_burst_o         (aw_fifo_burst_vec[ch]),
/////////////////////////////////////////////////////

                // AMBA AXI interface (W channel)
                // .wdata_o                (wdata_vec[ch]),
                .wstrb_o                (wstrb_vec[ch]),
                // .wlast_o                (wlast_vec[ch]),
                // .wvalid_o               (wvalid_vec[ch]),
                // .wready_i               (wready_vec[ch]),
        
                // AMBA AXI interface (B channel)
                .bresp_i                (bresp_i),
                .bvalid_i               (bvalid_i & (bid_i==ch)),
                .bready_o               (bready_vec[ch]),
        
                // AMBA AXI interface (AR channel)
                .araddr_o               (araddr_vec[ch]),
                .arlen_o                (arlen_vec[ch]),
                .arsize_o               (arsize_vec[ch]),
                .arburst_o              (arburst_vec[ch]),
                .arvalid_o              (arvalid_vec[ch]),
                .arready_i              (arready_vec[ch]),
        
                // AMBA AXI interface (R channel)
                // .rdata_i                (rdata_i),
                // .rresp_i                (rresp_i),
                .rlast_i                (rlast_i & (rid_i==ch))   // sbin_fix
                // .rvalid_i               (rvalid_i & (rid_i==ch)),
                // .rready_o               (rready_vec[ch])
            );

            assign  awid_vec[ch]        = ch;
            assign  wid_vec[ch]         = ch;
            assign  arid_vec[ch]        = ch;
        end
    endgenerate
endmodule
